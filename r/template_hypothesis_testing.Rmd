
```{r, include=FALSE, comment=NA, echo=FALSE}
library(knitr)
library(kableExtra)
library(magrittr)
library(ggplot2)
library(faraway)
library(DOS2)
library(RItools)
library(optmatch)
library(sensitivitymult)
library(dplyr)

source('utility.R')

set.seed(0) 
```


# MAIN R PIPELINE

# Load data

```{r, include=TRUE, comment=NA, echo=TRUE}
# SAMPLE FIRST 1000 - is this ok?
kickstarter_data <- read.csv('../data/kickstarter_data.csv')
```


# Define columns to work with

## List of all columns

```{r, include=TRUE, comment=NA, echo=TRUE}
x <- c( 'avg_reward_description',
        'blurb_length',
        'blurb_word_count',
        'category_art',
        'category_comics',
        'category_crafts',
        'category_dance',
        'category_design',
        'category_fashion',
        'category_film_video',
        'category_food',
        'category_games',
        'category_journalism',
        'category_music',
        'category_photography',
        'category_publishing',
        'category_technology',
        'category_theater',
        'country_at',
        'country_au',
        'country_be',
        'country_ca',
        'country_ch',
        'country_de',
        'country_dk',
        'country_es',
        'country_fr',
        'country_gb',
        'country_hk',
        'country_ie',
        'country_it',
        'country_jp',
        'country_lu',
        'country_mx',
        'country_nl',
        'country_no',
        'country_nz',
        'country_se',
        'country_sg',
        'country_us',
        'creator_project_no',
        'duration_campaign_creation_to_launch',
        'duration_campaign_launch_to_deadline',
        'faq',
        'has_faq',
        'has_one_dollar_reward',
        'is_asking_for_help',
        'is_not_first_project_from_creator',
        'is_project_we_love',
        'name_length',
        'name_word_count',
        'rewards_levels',
        'rewards_max',
        'rewards_mean',
        'rewards_min',
        'state',
        'usd_goal',
        'usd_pledged'
        )
```

# Define Treatment

## List of possible treatments

```{r, include=TRUE, comment=NA, echo=TRUE}
# treatment <- 'is_asking_for_help'
# treatment <- 'is_not_first_project_from_creator'
# treatment <- 'is_project_we_love'
# treatment <- 'has_faq'
# treatment <- 'has_one_dollar_reward'

kickstarter_data <- kickstarter_data %>%
  mutate(control=as.numeric(is_not_first_project_from_creator+is_project_we_love+has_one_dollar_reward==0),
         T1=as.numeric((is_not_first_project_from_creator==1)&(is_project_we_love+has_one_dollar_reward==0)),
         T2=as.numeric((is_project_we_love==1)&(is_not_first_project_from_creator+has_one_dollar_reward==0)),
         T3=as.numeric((has_one_dollar_reward==1)&(is_not_first_project_from_creator+is_project_we_love==0)))


kickstarter_data %>% group_by(control,T1,T2,T3) %>% summarise(n())

```

# Define outcome

## List of possible treatments

```{r, include=TRUE, comment=NA, echo=TRUE}
outcome <- 'state'
# outcome <- 'usd_pledge'
```


# Pre preprocess data

## Keep only columns of interest

```{r, include=TRUE, comment=NA, echo=TRUE}
#kickstarter_data <- kickstarter_data[, (names(kickstarter_data) %in% x)]
```

## Add treatment to the data under column z

```{r, include=TRUE, comment=NA, echo=TRUE}
#names(kickstarter_data)[names(kickstarter_data) == treatment] <- 'z'
```

## Add outcome to the data under column y

```{r, include=TRUE, comment=NA, echo=TRUE}
names(kickstarter_data)[names(kickstarter_data) == outcome] <- 'y'
```




# Remove outliers

## With outliers

```{r, include=TRUE, comment=NA, echo=TRUE}
ggplot(kickstarter_data, aes(y = usd_pledged)) + 
  geom_boxplot(fill = "#4271AE", colour =  "#1F3552", alpha = 0.7) +
  ggtitle("Boxplot of usd_pledged with outliers")
```

## Without outliers

### Remove outliers

```{r, include=TRUE, comment=NA, echo=TRUE}
outliers <- boxplot(kickstarter_data$usd_pledged, plot=FALSE)$out
kickstarter_data <- kickstarter_data[-which(kickstarter_data$usd_pledged %in% outliers),]
```

```{r, include=TRUE, comment=NA, echo=TRUE}
ggplot(kickstarter_data, aes(y = usd_pledged)) + 
  geom_boxplot(fill = "#4271AE", colour =  "#1F3552", alpha = 0.7) +
  ggtitle("Boxplot of usd_pledged without outliers") 
```

## Filtering

```{r}
# Less than $1k goal 
kickstarter_data <- kickstarter_data %>% filter(usd_goal>1000)
nrow(kickstarter_data)
```

# Exploratory analysis

```{r, include=TRUE, comment=NA, echo=TRUE}
head(kickstarter_data)
```


```{r, include=TRUE, comment=NA, echo=TRUE}
summary(kickstarter_data)
```

## Define Treatment

```{r}
# T1
kickstarter_data$z <- kickstarter_data$T1
kickstarter_data <- kickstarter_data %>% filter(z+control==1) %>% select(-c(control,T1,T2,T3))
```

# Vizualisations 

## USD pledged density visualization

```{r, include=TRUE, comment=NA, echo=TRUE}
ggplot(data=kickstarter_data, aes(x=usd_pledged, group=as.factor(z), fill=as.factor(z))) +
  geom_density(alpha=0.5) + 
  theme_bw() +
  scale_fill_discrete(name = "", labels = c('Control', 'Treatment')) +
  theme(legend.position = "top")
```


## Box vizualisation


```{r, include=TRUE, comment=NA, echo=TRUE}
ggplot(kickstarter_data, aes(x = category_art, y = usd_pledged, group=as.factor(z))) + 
  geom_boxplot(aes(fill = as.factor(z)))
```




# Method

## Data structure to save the results

```{r, include=TRUE, comment=NA, echo=TRUE}
hypothesis.results <- data.frame('when' = c(), 
                                 'tau' = c(),
                                 'V' = c(),
                                 'CI_lower' = c(),
                                 'CI_upper' = c(),
                                 'p_Fisher' = c(),
                                 'p_Neyman' = c(),
                                 'Gamma' = c())
```

## Estimator

```{r, include=TRUE, comment=NA, echo=TRUE}
N0 <- sum(1 - kickstarter_data$z)
N1 <- sum(kickstarter_data$z)
N <- N0 + N1
```


```{r, include=TRUE, comment=NA, echo=TRUE}
tau_obs <- sum(kickstarter_data$z*kickstarter_data$y) / N1 - sum((1-kickstarter_data$z)*kickstarter_data$y) / N0
formatC(tau_obs, format = "e", digits = 4)
```

```{r}

tau_hat_dm_e <- 1/(N11)*sum(W*Y*Z) - 1/(N10)*sum((1-W)*Y*Z)

# Variance Estimator

Y_bar_11 <- sum(vernby[vernby$citizen==1 & vernby$woman==1,3])/(N11+N10)
Y_bar_10 <- sum(vernby[vernby$citizen==1 & vernby$woman==0,3])/(N11+N10)

V1_hat_e <- sum((Y-Y_bar_11)^2*W*Z)/(N11-1)
V0_hat_e <- sum((Y-Y_bar_10)^2*(1-W)*Z)/(N10-1)

V_bar_e <- V1_hat_e/N11 + V0_hat_e/N10
```

```{r, include=TRUE, comment=NA, echo=TRUE}
Y0_mean <- ((1-kickstarter_data$z)*kickstarter_data$y)/N0
Y1_mean <- (kickstarter_data$z*kickstarter_data$y)/N1

V0 <- sum(((1-kickstarter_data$z)*kickstarter_data$y - Y0_mean)^2)/(N0-1)
V1 <- sum((kickstarter_data$z*kickstarter_data$y - Y1_mean)^2)/(N1-1)

V10 <- sum((kickstarter_data$z*kickstarter_data$y - (1-kickstarter_data$z)*kickstarter_data$y) - (Y1_mean -Y0_mean))/(N-1)

V <- V1/N1 + V0/N0
formatC(V, format = "e", digits = 4)
```


# Neyman's CI

```{r, include=TRUE, comment=NA, echo=TRUE}
# Upper bound
CI.upper <- tau_obs + 1.96*sqrt(V/N)
formatC(CI.upper, format = "e", digits = 4)

# Lower bound
CI.lower <- tau_obs - 1.96*sqrt(V/N)
formatC(CI.lower, format = "e", digits = 4)
```

# Neyman's p-value

```{r}
p_Neyman <- pnorm((tau_obs-0)/sqrt(V),lower.tail = FALSE)
p_Neyman
```

# Fisher permutation test

```{r, include=TRUE, comment=NA, echo=TRUE}
Fisher_test.max_iter <- 1000
Power.max_iter <- 1000
alpha = 0.05
```

## Perform Fisher permutation test

```{r, include=TRUE, comment=NA, echo=TRUE}
T = c()
for(i in 1:Fisher_test.max_iter) {
  z <- sample(kickstarter_data$z, N, replace=FALSE)
  T[i] = sum(z*kickstarter_data$y)/N1 - sum((1 - z)*kickstarter_data$y)/N0
}
```

## P value

```{r, include=TRUE, comment=NA, echo=TRUE}
p.Fisher = mean(as.numeric(T >= tau_obs))
formatC(p.Fisher, format = "e", digits = 5)
```

## Power of the test

```{r, include=TRUE, comment=NA, echo=TRUE}
P = c()
for(j in 1:Power.max_iter) {
  T = c()
  for(i in 1:Fisher_test.max_iter) {
    z <- sample(kickstarter_data$z, N, replace=FALSE)
    T[i] = sum(z*kickstarter_data$y)/N1 - sum((1 - z)*kickstarter_data$y)/N0
  }
  P[j] = mean(as.numeric(T >= tau_obs))
}
```


```{r, include=TRUE, comment=NA, echo=TRUE}
power.Fisher <- mean(as.numeric(P <= alpha))
formatC(power.Fisher, format = "e", digits = 4)
```



# Matching

## Balance of daa

```{r, include=TRUE, comment=NA, echo=TRUE}
plot(xBalance(z ~ creator_project_no + duration_campaign_launch_to_deadline +
                faq + has_faq + has_one_dollar_reward + is_asking_for_help + 
                is_project_we_love + name_length + name_word_count + rewards_levels,
              data=kickstarter_data))
```





```{r, include=TRUE, comment=NA, echo=TRUE}
plot(xBalance(z ~ . - y,
              data=kickstarter_data))
```





## Propensity scores

```{r, include=TRUE, comment=NA, echo=TRUE}
#kickstarter_data$prop <- glm(z ~ avg_reward_description + blurb_length + blurb_word_count + category_art + category_comics + category_crafts + category_dance + category_design + category_fashion + category_film_video + category_food + category_games + category_journalism + category_music + category_photography + category_publishing + category_technology + category_theater + country_at + country_au + country_be + country_ca + country_ch + country_de + country_dk + country_es + country_fr + country_gb + country_hk + country_ie + country_it + country_jp + country_lu + country_mx + country_nl + country_no + country_nz + country_se + country_sg + country_us + has_one_dollar_reward + is_asking_for_help + duration_campaign_creation_to_launch + duration_campaign_launch_to_deadline + is_project_we_love + name_length + name_word_count  + rewards_levels + rewards_max + rewards_mean + rewards_min + faq + has_faq ,
#                             family=binomial,
#                             data=kickstarter_data)$fitted.values

toRemove <- c("creator_project_no","usd_goal","usd_pledged",'is_not_first_project_from_creator','state')
covariates <- x[!c(x %in% toRemove)]
categories <- colnames(data_clean)[grepl("^category_",colnames(data_clean))]
covariates_to_match <- c("avg_reward_description","blurb_word_count","duration_campaign_launch_to_deadline",
                         "has_faq","rewards_levels","rewards_mean","has_one_dollar_reward",categories)
  
fmla <- as.formula(paste('z~',paste0(covariates_to_match,collapse='+')))
kickstarter_data$prop <- glm(fmla, family=binomial, data=kickstarter_data)$fitted.values

# Remove creator_project_no  + usd_goal + usd_pledged 
```

The density of the propensity scores is showed with the code bellow:

```{r, include=TRUE, comment=NA, echo=TRUE}
ggplot(data=kickstarter_data, aes(x=prop, group=as.factor(z), fill=as.factor(z))) + 
  geom_density(alpha=0.5) + theme_bw()
```


```{r, include=TRUE, comment=NA, echo=TRUE}

```



```{r}
# Multivariate matching
```




```{r}
# Multivariate matching
match.nocaliper <- smahal(kickstarter_data$z, kickstarter_data[,covariates_to_match])
ms.nocaliper <- pairmatch(match.nocaliper, data=kickstarter_data)
fmla <- as.formula(paste('z~',paste0(covariates_to_match,collapse='+'),'+ strata(ms.nocaliper) - 1'))
adat.1 <- summarize.match(kickstarter_data, ms.nocaliper)
plot(xBalance(fmla,data=kickstarter_data))

```


```{r}
mean_diff_before <- mean(abs(adat.1$prop.0 - adat.1$prop.1))
print(mean_diff_before)

max_diff_before <- max(abs(adat.1$prop.0 - adat.1$prop.1))
print(max_diff_before)

# Add propensity score caliper
match.withcaliper <- addcaliper(match.nocaliper, z=kickstarter_data$z, p=kickstarter_data$prop, caliper=0.1)
ms.withcaliper <- pairmatch(match.withcaliper, data=kickstarter_data)
adat.2 <- summarize.match(kickstarter_data, ms.withcaliper)
fmla <- as.formula(paste('z~',paste0(covariates_to_match,collapse='+'),'+ strata(ms.withcaliper) - 1'))
plot(xBalance(fmla,data=kickstarter_data))

mean_diff_after <- mean(abs(adat.2$prop.0 - adat.2$prop.1))
print(mean_diff_after)

max_diff_after <- max(abs(adat.2$prop.0 - adat.2$prop.1))
print(max_diff_after)

```
Sensitivity Analysis

```{r, include=TRUE, comment=NA, echo=TRUE}
data.senm <- cast.senm(kickstarter_data, ms.withcaliper, two.outcomes=FALSE)
senm(data.senm$y, data.senm$z, mset=data.senm$mset, gamma = 1, inner = 0, trim = 'Inf')
```


```{r, include=TRUE, comment=NA, echo=TRUE}
data.senm <- cast.senm(kickstarter_data, ms.withcaliper, two.outcomes=FALSE)
senm(data.senm$y, data.senm$z, mset=data.senm$mset, gamma = 1.65, inner = 0, trim = 'Inf')
```









## Save results

```{r, include=TRUE, comment=NA, echo=TRUE}
hypothesis.results <- data.frame('when' = c(), 
                                 'tau' = c(),
                                 'V' = c(),
                                 'CI_lower' = c(),
                                 'CI_upper' = c(),
                                 'p_Fisher' = c(),
                                 'p_Neyman' = c(),
                                 'Gamma' = c())
  
  
current.results <- data.frame('when' = c('before matching'), 
                              'tau' = c(tau_obs),
                               'V' = c(V),
                               'CI_lower' = c(CI.lower),
                               'CI_upper' = c(CI.upper),
                               'p_Fisher' = c(p),
                               'power_Fisher' = c(""),
                               'Gamma' = c(""))

#newdf <- rbind(df, de)

# Set this to name of your experiment
csvname <- "H1_isNotFirstProject"
f <- paste0('../results/',csvname,'.csv')

if (!file.exists(f)) {
  write.csv(current.results, f)
} else print("File exists already")

```









```{r, include=TRUE, comment=NA, echo=TRUE}
col <- 'usd_pledged' 
ggplot(data=kickstarter_data, aes(x=col, group=z)) +
  geom_density(alpha=0.5) +
  theme_bw() + 
  scale_fill_discrete(name = "Group", labels = c('Control', 'Treatment')) +
  geom_vline(aes(xintercept=mean(col)), color="blue", linetype="dashed", size=1)
```


```{r, include=TRUE, comment=NA, echo=TRUE}
boxplot(kickstarter_data$usd_pledged, main = "After removing the outliers")
```



```{r, include=TRUE, comment=NA, echo=TRUE}
boxplot(kickstarter_data$usd_pledged, main = "After removing the outliers")
```





        
        
        


## Part A

### Question 1

Looking at the graph bellow, the covariates that seem to be the most imbalanced in the dataset are: "faminc", "edm" and "edmissm".

```{r, include=TRUE, comment=NA, echo=TRUE}
plot(xBalance(zb ~ faminc + incmiss + black + hisp + afqtpct + edmissm + edm + female,
              data=dynarski))
```

\newpage
### Question 2

```{r, include=TRUE, comment=NA, echo=TRUE, message=FALSE}
ggplot(data=dynarski, aes(x=faminc)) + 
  geom_histogram(bins=20) + 
  facet_wrap(.~zb, scales="free") + 
  theme_bw()
```

\newpage
```{r, include=TRUE, comment=NA, echo=TRUE, message=FALSE}
ggplot(data=dynarski, aes(x=as.factor(incmiss))) + 
  geom_histogram(stat="count") + 
  facet_wrap(.~zb, scales="free") + 
  theme_bw()
```

\newpage
```{r, include=TRUE, comment=NA, echo=TRUE, message=FALSE}
ggplot(data=dynarski, aes(x=as.factor(black))) + 
  geom_histogram(stat="count") + 
  facet_wrap(.~zb, scales="free") + 
  theme_bw()
```

\newpage
```{r, include=TRUE, comment=NA, echo=TRUE, message=FALSE}
ggplot(data=dynarski, aes(x=as.factor(hisp))) + 
  geom_histogram(stat="count") + 
  facet_wrap(.~zb, scales="free") + 
  theme_bw()
```

\newpage
```{r, include=TRUE, comment=NA, echo=TRUE, message=FALSE}
ggplot(data=dynarski, aes(x=afqtpct)) + 
  geom_histogram(bins=30) + 
  facet_wrap(.~zb, scales="free") + 
  theme_bw()
```

\newpage
```{r, include=TRUE, comment=NA, echo=TRUE, message=FALSE}
ggplot(data=dynarski, aes(x=as.factor(edmissm))) + 
  geom_histogram(stat="count") + 
  facet_wrap(.~zb, scales="free") + 
  theme_bw()
```

\newpage
```{r, include=TRUE, comment=NA, echo=TRUE, message=FALSE}
ggplot(data=dynarski, aes(x=as.factor(edm))) + 
  geom_histogram(stat="count") + 
  facet_wrap(.~zb, scales="free") + 
  theme_bw()
```

\newpage
```{r, include=TRUE, comment=NA, echo=TRUE, message=FALSE}
ggplot(data=dynarski, aes(x=as.factor(female))) + 
  geom_histogram(stat="count") + 
  facet_wrap(.~zb, scales="free") + 
  theme_bw()
```

\newpage
## Question 3

The propensity scores are computed with the code bellow:

```{r, include=TRUE, comment=NA, echo=TRUE}
dynarski$prop <- glm(zb	~ faminc + incmiss + black + hisp + afqtpct + edmissm 
                     + edm + female,
                    family=binomial,
                    data=dynarski)$fitted.values
```

The density of the propensity scores is showed with the code bellow:

```{r, include=TRUE, comment=NA, echo=TRUE}
ggplot(data=dynarski, aes(x=prop, group=as.factor(zb), fill=as.factor(zb))) + 
  geom_density(alpha=0.5) + theme_bw()
```


\newpage
# Part B

## Question 1

```{r, include=TRUE, comment=NA, echo=TRUE}
covariates <- c("faminc", "incmiss", "black", "hisp", "afqtpct", "edmissm",
                "edm", "female")
```


```{r, include=TRUE, comment=NA, echo=TRUE}
match.nocaliper <- smahal(dynarski$zb, dynarski[,covariates])
ms.nocaliper <- pairmatch(match.nocaliper, data=dynarski)
plot(xBalance(zb	~ faminc + incmiss + black + hisp + afqtpct + edmissm + edm + female 
              + strata(ms.nocaliper) - 1,
              data=dynarski))
```

## Question 2

### Sub Question a

The average absolute difference in propensity scores within matched pairs is given by the code bellow:

```{r, include=TRUE, comment=NA, echo=TRUE}
data <- summarize.match(dynarski, ms.nocaliper)
formatC(mean(abs(data$prop.0 - data$prop.1)), format = "e", digits = 4)
```

The maximum absolute difference in propensity score is given by the code bellow:

```{r, include=TRUE, comment=NA, echo=TRUE}
formatC(max(abs(data$prop.0 - data$prop.1)), format = "e", digits = 4)
```


\newpage
### Sub Question b

```{r, include=TRUE, comment=NA, echo=TRUE}
match.withcaliper <- addcaliper(match.nocaliper, z=dynarski$zb, p=dynarski$prop, caliper=0.1)
ms.withcaliper <- pairmatch(match.withcaliper, data=dynarski)
plot(xBalance(zb	~ faminc + incmiss + black + hisp + afqtpct + edmissm + edm + female 
              + strata(ms.withcaliper) - 1,
              data=dynarski))
```


### Sub Question c

The average absolute difference in propensity scores within matched pairs is given by the code bellow:

```{r, include=TRUE, comment=NA, echo=TRUE}
data <- summarize.match(dynarski, ms.withcaliper)
formatC(mean(abs(data$prop.0 - data$prop.1)), format = "e", digits = 4)
```

The maximum absolute difference in propensity score is given by the code bellow:

```{r, include=TRUE, comment=NA, echo=TRUE}
formatC(max(abs(data$prop.0 - data$prop.1)), format = "e", digits = 4)
```


## Question 3

In both matches, we can see that the absolute standard difference strongly decreases before and after matching. The standard difference is nw close to zero for every covarite which is a sign that the two matches worked. Plus with the caliper, helps to reduce the average and the max of the absolute propensity scores.



\newpage
## Part C

## Question 1

### Sub Question a

```{r, include=TRUE, comment=NA, echo=TRUE}
ms.withcaliper.1to5 <- pairmatch(match.withcaliper, data=dynarski, control=5)
plot(xBalance(zb	~ faminc + incmiss + black + hisp + afqtpct + edmissm + edm + female 
              + strata(ms.withcaliper.1to5) - 1,
              data=dynarski))
```

\newpage
### Sub Question b

```{r, include=TRUE, comment=NA, echo=TRUE}
match.withcaliper.almost_exact <- addalmostexact(match.withcaliper,
                                                 z=dynarski$zb,
                                                 f=dynarski$edm, mult=5)
ms.withcaliper.1to5.almost_exact <- pairmatch(match.withcaliper.almost_exact,
                                  data=dynarski, control=5)
plot(xBalance(zb	~ faminc + incmiss + black + hisp + afqtpct + edmissm + edm + female 
              + strata(ms.withcaliper.1to5.almost_exact) - 1,
              data=dynarski))
```

\newpage
### Sub Question c

Although visually it seems that most absolute standardized differences were reduced, the average absolute difference in propensity scores within matched pairs increases after trying to force balance on the "edm" variable. Hence it does not improve the matching.

```{r, include=TRUE, comment=NA, echo=TRUE}
data <- summarize.match(dynarski, ms.withcaliper.1to5)
formatC(mean(abs(data$prop.0 - data$prop.1)), format = "e", digits = 4)
```

```{r, include=TRUE, comment=NA, echo=TRUE}
data <- summarize.match(dynarski, ms.withcaliper.1to5.almost_exact)
formatC(mean(abs(data$prop.0 - data$prop.1)), format = "e", digits = 4)
```

\newpage
## Question 2

### Sub Question a

Since trying to force balance on the "edm" variable did not help improve the matching, we remove that setp.

```{r, include=TRUE, comment=NA, echo=TRUE}
ms.withcaliper.1to15 <- pairmatch(match.withcaliper, data=dynarski, control=15)
plot(xBalance(zb	~ faminc + incmiss + black + hisp + afqtpct + edmissm + edm + female 
              + strata(ms.withcaliper.1to15) - 1,
              data=dynarski))
```



### Sub Question b

Looking at the chart we can say that the standardized differences is smaller with the 1 to 1 matching than for the 1 to 15 matching. This may indicate that we are trying to match too many treatment for a same control and hence we are decreasing the validity. This makes the matching more susceptible to confounding.

\newpage
# Problem 2

## Part A

### Question 1

We build the two matched sets with the code bellow:

```{r, include=TRUE, comment=NA, echo=TRUE}
match <- smahal(adynarski$z, adynarski[,covariates])
match <- addcaliper(match, z=adynarski$z, p=adynarski$prop, caliper=0.1)
ms.withcaliper.1to1 <- pairmatch(match, control=1, data=adynarski)
ms.withcaliper.1to15 <- pairmatch(match, control=15, data=adynarski)
```


### Question 2


```{r, include=TRUE, comment=NA, echo=TRUE}
data.senm <- cast.senm(adynarski, ms.withcaliper.1to1, two.outcomes=FALSE)
senm(data.senm$y, data.senm$z, mset=data.senm$mset, gamma = 1, inner = 0, trim = 'Inf')
```


```{r, include=TRUE, comment=NA, echo=TRUE}
data.senm <- cast.senm(adynarski, ms.withcaliper.1to1, two.outcomes=FALSE)
senm(data.senm$y, data.senm$z, mset=data.senm$mset, gamma = 1.2, inner = 0, trim = 'Inf')
```


\newpage
### Question 3

```{r, include=TRUE, comment=NA, echo=TRUE}
data.senm <- cast.senm(adynarski, ms.withcaliper.1to15, two.outcomes=FALSE)
senm(data.senm$y, data.senm$z, mset=data.senm$mset, gamma = 1, inner = 0, trim = 'Inf')
```

```{r, include=TRUE, comment=NA, echo=TRUE}
data.senm <- cast.senm(adynarski, ms.withcaliper.1to15, two.outcomes=FALSE)
senm(data.senm$y, data.senm$z, mset=data.senm$mset, gamma = 1.2, inner = 0, trim = 'Inf')
```


### Question 4

For the 1 to 1 matching, we end up rejecting the null hypothesis for $gamma = 1$ although we wouldn't for $gamma = 1.2$ therefore our intepretation is very sensitive to unmeasured confounding while for the 1 to 15 matching the p value changes less and our decision will be consistant no matter the gamma which means that it is more robust to unmeasured confounding.


\newpage
# Part B

### Question 1

```{r, include=TRUE, comment=NA, echo=TRUE}
quantile(adynarski$prop, c(.2, .4, .6, .8)) 
```

### Question 2

```{r, include=TRUE, comment=NA, echo=TRUE}
q20 = quantile(adynarski$prop, 0.2) 
q40 = quantile(adynarski$prop, 0.4) 
q60 = quantile(adynarski$prop, 0.6) 
q80 = quantile(adynarski$prop, 0.8) 
```

```{r, include=TRUE, comment=NA, echo=TRUE}
strata.1 <- as.numeric(0 <= adynarski$prop & adynarski$prop < q20)
strata.1.data <- adynarski[0 <= adynarski$prop & adynarski$prop < q20,]
strata.1.N1 <- sum(strata.1.data$z)
strata.1.N0 <- sum(1-strata.1.data$z)
strata.1.N <- strata.1.N0 + strata.1.N1
strata.1.tau = sum(strata.1.data$z*strata.1.data$y)/strata.1.N1 -
  sum((1-strata.1.data$z)*strata.1.data$y)/strata.1.N0
```

```{r, include=TRUE, comment=NA, echo=TRUE}
strata.2 <- as.numeric(q20 <= adynarski$prop & adynarski$prop < q40)
strata.2.data <- adynarski[q20 <= adynarski$prop & adynarski$prop < q40,]
strata.2.N1 <- sum(strata.2.data$z)
strata.2.N0 <- sum(1-strata.2.data$z)
strata.2.N <- strata.2.N0 + strata.2.N1
strata.2.tau = sum(strata.2.data$z*strata.2.data$y)/strata.2.N1 -
  sum((1-strata.2.data$z)*strata.2.data$y)/strata.2.N0
```

```{r, include=TRUE, comment=NA, echo=TRUE}
strata.3 <- as.numeric(q40 <= adynarski$prop & adynarski$prop < q60)
strata.3.data <- adynarski[q40 <= adynarski$prop & adynarski$prop < q60,]
strata.3.N1 <- sum(strata.3.data$z)
strata.3.N0 <- sum(1-strata.3.data$z)
strata.3.N <- strata.3.N0 + strata.3.N1
strata.3.tau = sum(strata.3.data$z*strata.3.data$y)/strata.3.N1 -
  sum((1-strata.3.data$z)*strata.3.data$y)/strata.3.N0
```

```{r, include=TRUE, comment=NA, echo=TRUE}
strata.4 <- as.numeric(q60 <= adynarski$prop & adynarski$prop < q80)
strata.4.data <- adynarski[q60 <= adynarski$prop & adynarski$prop < q80,]
strata.4.N1 <- sum(strata.4.data$z)
strata.4.N0 <- sum(1-strata.4.data$z)
strata.4.N <- strata.4.N0 + strata.4.N1
strata.4.tau = sum(strata.4.data$z*strata.4.data$y)/strata.4.N1 -
  sum((1-strata.4.data$z)*strata.4.data$y)/strata.4.N0
```

```{r, include=TRUE, comment=NA, echo=TRUE}
strata.5 <- as.numeric(q80 <= adynarski$prop & adynarski$prop <= 1)
strata.5.data <- adynarski[q80 <= adynarski$prop & adynarski$prop <= 1,]
strata.5.N1 <- sum(strata.5.data$z)
strata.5.N0 <- sum(1-strata.5.data$z)
strata.5.N <- strata.5.N0 + strata.5.N1
strata.5.tau = sum(strata.5.data$z*strata.5.data$y)/strata.5.N1 -
  sum((1-strata.5.data$z)*strata.5.data$y)/strata.5.N0
```


\newpage
```{r, include=TRUE, comment=NA, echo=TRUE}
data.frame("Strata"=c("[0, q20[", "[q20, q40[", "[q40, q60[", "[q60, q80[", "[q80, 1]"), 
           "Treatment" = c(strata.1.N1, strata.2.N1, strata.3.N1, strata.4.N1, strata.5.N1),
           "Control" = c(strata.1.N0, strata.2.N0, strata.3.N0, strata.4.N0, strata.5.N0))
```


\newpage
### Question 3

The stratified difference in mean is:

```{r, include=TRUE, comment=NA, echo=TRUE}
N <- as.numeric(length(adynarski$z))
tau = (strata.1.tau*strata.1.N + strata.2.tau*strata.2.N + strata.3.tau*strata.3.N +
         strata.4.tau*strata.4.N + strata.5.tau*strata.5.N) / N
formatC(tau, format = "e", digits = 4)
```

The variance is given by the code bellow:


```{r, include=TRUE, comment=NA, echo=TRUE}
Y.bar1 <- mean(adynarski$z*adynarski$y)
Y.bar0 <- mean((1-adynarski$z)*adynarski$y)

Y.0 <- (1-adynarski$z)*(adynarski$y - Y.bar0)^2
Y.1 <- adynarski$z*(adynarski$y - Y.bar1)^2

V.1 <- (1/strata.1.N1)*sum(strata.1*Y.1)/(strata.1.N - 1) +
  (1/strata.1.N0)*sum(strata.1*Y.0)/(strata.1.N - 1)

V.2 <- (1/strata.2.N1)*sum(strata.2*Y.1)/(strata.2.N - 1) +
  (1/strata.2.N0)*sum(strata.2*Y.0)/(strata.2.N - 1)

V.3 <- (1/strata.3.N1)*sum(strata.3*Y.1)/(strata.3.N - 1) +
  (1/strata.3.N0)*sum(strata.3*Y.0)/(strata.3.N - 1)

V.4 <- (1/strata.4.N1)*sum(strata.4*Y.1)/(strata.4.N - 1) +
  (1/strata.4.N0)*sum(strata.4*Y.0)/(strata.4.N - 1)

V.5 <- (1/strata.5.N1)*sum(strata.5*Y.1)/(strata.5.N - 1) +
  (1/strata.5.N0)*sum(strata.5*Y.0)/(strata.5.N - 1)

V <- (strata.1.N/N)^2*V.1 + (strata.2.N/N)^2*V.2 + (strata.3.N/N)^2*V.3 +
  (strata.4.N/N)^2*V.4 + (strata.5.N/N)^2*V.5
formatC(V, format = "e", digits = 4)
```



### Question 4

The $95%$ confidence interval is given by:


```{r, include=TRUE, comment=NA, echo=TRUE}
# Upper bound
formatC(1.96*sqrt(V/N) + tau, format = "e", digits = 4)

# Lower bound
formatC(-1.96*sqrt(V/N) + tau, format = "e", digits = 4)
```

The Neyman null hypothesis states that the average treatment effect is zero however 0 does not belong to our $95%$ confidence interval hence this is a strong evidence that we should reject the Neyan null hypothesis.


### Question 5

One of the major flow of this apporch is the disproportionary small ratio of treatment compared to control in the starta. A way to improve it would be to a 1 to k matching.







\newpage
# Problem 3

```{r, include=FALSE, comment=NA, echo=FALSE}
load("Problem_3/rerand.Rdata")
source("Problem_3/rerand.R")
```


```{r, include=TRUE, comment=NA, echo=TRUE}
N1 = 100
N0 = 100
N = N0 + N1
max_iter <- 10000

omega.crd <- c()
omega.scrd <- c()
omega.rerand <- c()
```


## Question 1

### Sub Question a


```{r, include=TRUE, comment=NA, echo=TRUE}
data <- science.1
Zobs = sample(c(rep(0, N0), rep(1, N1)), N, replace=FALSE)
data$Yobs = observe.Yobs(data, Zobs)
Tobs = sum(Zobs*data$Yobs)/N1 - sum((1-Zobs)*data$Yobs)/N0
T = c()
for(i in 1:max_iter) {
  Z = sample(Zobs, N, replace=FALSE)
  T[i] = sum(Z*data$Yobs)/N1 - sum((1-Z)*data$Yobs)/N0
}
formatC(mean(as.numeric(T >= Tobs)), format = "e", digits = 4)
```



### Sub Question b


```{r, include=TRUE, comment=NA, echo=TRUE}
data <- science.1
P = c()
alpha = 0.05
for(i in 1:200) {
  
  Zobs = sample(c(rep(0, N0), rep(1, N1)), N, replace=FALSE)
  data$Yobs = observe.Yobs(data, Zobs)
  Tobs = sum(Zobs*data$Yobs)/N1 - sum((1-Zobs)*data$Yobs)/N0
  
  T = c()
  for(j in 1:max_iter) {
    Z = sample(Zobs, N, replace=FALSE)
    T[j] = sum(Z*data$Yobs)/N1 - sum((1-Z)*data$Yobs)/N0
  }
  P[i] = mean(as.numeric(T >= Tobs))
}
omega.crd[1] <- mean(as.numeric(P <= 0.05))
formatC(omega.crd[1], format = "e", digits = 4)
```

The quantities $\omega_1^{crd}$ is the power of the test, basically how cobnfident we are in rejecting the null hypothesis based on the p value.


## Sub Question c

```{r, include=TRUE, comment=NA, echo=TRUE}
data <- science.2
P = c()
alpha = 0.05
for(i in 1:200) {
  
  Zobs = sample(c(rep(0, N0), rep(1, N1)), N, replace=FALSE)
  data$Yobs = observe.Yobs(data, Zobs)
  Tobs = sum(Zobs*data$Yobs)/N1 - sum((1-Zobs)*data$Yobs)/N0
  
  T = c()
  for(j in 1:max_iter) {
    Z = sample(Zobs, N, replace=FALSE)
    T[j] = sum(Z*data$Yobs)/N1 - sum((1-Z)*data$Yobs)/N0
  }
  P[i] = mean(as.numeric(T >= Tobs))
}
omega.crd[2] <- mean(as.numeric(P <= 0.05))
formatC(omega.crd[2], format = "e", digits = 4)
```

```{r, include=TRUE, comment=NA, echo=TRUE}
data <- science.3
P = c()
alpha = 0.05
for(i in 1:200) {
  
  Zobs = sample(c(rep(0, N0), rep(1, N1)), N, replace=FALSE)
  data$Yobs = observe.Yobs(data, Zobs)
  Tobs = sum(Zobs*data$Yobs)/N1 - sum((1-Zobs)*data$Yobs)/N0
  
  T = c()
  for(j in 1:max_iter) {
    Z = sample(Zobs, N, replace=FALSE)
    T[j] = sum(Z*data$Yobs)/N1 - sum((1-Z)*data$Yobs)/N0
  }
  P[i] = mean(as.numeric(T >= Tobs))
}
omega.crd[3] <- mean(as.numeric(P <= 0.05))
formatC(omega.crd[3], format = "e", digits = 4)
```

\newpage
```{r, include=TRUE, comment=NA, echo=TRUE}
data <- science.4
P = c()
alpha = 0.05
for(i in 1:200) {
  
  Zobs = sample(c(rep(0, N0), rep(1, N1)), N, replace=FALSE)
  data$Yobs = observe.Yobs(data, Zobs)
  Tobs = sum(Zobs*data$Yobs)/N1 - sum((1-Zobs)*data$Yobs)/N0
  
  T = c()
  for(j in 1:max_iter) {
    Z = sample(Zobs, N, replace=FALSE)
    T[j] = sum(Z*data$Yobs)/N1 - sum((1-Z)*data$Yobs)/N0
  }
  P[i] = mean(as.numeric(T >= Tobs))
}
omega.crd[4] <- mean(as.numeric(P <= 0.05))
formatC(omega.crd[4], format = "e", digits = 4)
```

```{r, include=TRUE, comment=NA, echo=TRUE}
data.frame("Science"=c(1, 2, 3, 4), "omega.crd"=omega.crd)
```

\newpage
## Questions 2


### Sub Question a

```{r, include=TRUE, comment=NA, echo=TRUE}
strata <- X > 0
```


```{r, include=TRUE, comment=NA, echo=TRUE}
data <- science.1
Zobs = rep(0, N)
Zobs.0 = sample(c(rep(0, N0/2), rep(1, N1/2)), N/2, replace=FALSE)
Zobs.1 = sample(c(rep(0, N0/2), rep(1, N1/2)), N/2, replace=FALSE)
Zobs[strata] <- Zobs.1
Zobs[!strata] <- Zobs.0
data$Yobs = observe.Yobs(data, Zobs)

Tobs = sum(Zobs*data$Yobs)/N1 - sum((1-Zobs)*data$Yobs)/N0
T = c()
for(i in 1:max_iter) {
  Z = sample(Zobs, N, replace=FALSE)
  T[i] = sum(Z*data$Yobs)/N1 - sum((1-Z)*data$Yobs)/N0
}
formatC(mean(as.numeric(T >= Tobs)), format = "e", digits = 4)
```

### Sub Question b


```{r, include=TRUE, comment=NA, echo=TRUE}
data <- science.1
P = c()
alpha = 0.05
for(i in 1:200) {
  
  Zobs = rep(0, N)
  Zobs.0 = sample(c(rep(0, N0/2), rep(1, N1/2)), N/2, replace=FALSE)
  Zobs.1 = sample(c(rep(0, N0/2), rep(1, N1/2)), N/2, replace=FALSE)
  Zobs[strata] <- Zobs.1
  Zobs[!strata] <- Zobs.0
  data$Yobs = observe.Yobs(data, Zobs)
  Tobs = sum(Zobs*data$Yobs)/N1 - sum((1-Zobs)*data$Yobs)/N0
  
  T = c()
  for(j in 1:max_iter) {
    Z = rep(0, N)
    Z.0 = sample(c(rep(0, N0/2), rep(1, N1/2)), N/2, replace=FALSE)
    Z.1 = sample(c(rep(0, N0/2), rep(1, N1/2)), N/2, replace=FALSE)
    Z[strata] <- Z.1
    Z[!strata] <- Z.0
    T[j] = sum(Z*data$Yobs)/N1 - sum((1-Z)*data$Yobs)/N0
  }
  P[i] = mean(as.numeric(T >= Tobs))
}
omega.scrd[1] <- mean(as.numeric(P <= 0.05))
formatC(omega.scrd[1], format = "e", digits = 4)
```


```{r, include=TRUE, comment=NA, echo=TRUE}
data <- science.2
P = c()
alpha = 0.05
for(i in 1:200) {
  
  Zobs = rep(0, N)
  Zobs.0 = sample(c(rep(0, N0/2), rep(1, N1/2)), N/2, replace=FALSE)
  Zobs.1 = sample(c(rep(0, N0/2), rep(1, N1/2)), N/2, replace=FALSE)
  Zobs[strata] <- Zobs.1
  Zobs[!strata] <- Zobs.0
  data$Yobs = observe.Yobs(data, Zobs)
  Tobs = sum(Zobs*data$Yobs)/N1 - sum((1-Zobs)*data$Yobs)/N0
  
  T = c()
  for(j in 1:max_iter) {
    Z = rep(0, N)
    Z.0 = sample(c(rep(0, N0/2), rep(1, N1/2)), N/2, replace=FALSE)
    Z.1 = sample(c(rep(0, N0/2), rep(1, N1/2)), N/2, replace=FALSE)
    Z[strata] <- Z.1
    Z[!strata] <- Z.0
    T[j] = sum(Z*data$Yobs)/N1 - sum((1-Z)*data$Yobs)/N0
  }
  P[i] = mean(as.numeric(T >= Tobs))
}
omega.scrd[2] <- mean(as.numeric(P <= 0.05))
formatC(omega.scrd[2], format = "e", digits = 4)
```

\newpage
```{r, include=TRUE, comment=NA, echo=TRUE}
data <- science.3
P = c()
alpha = 0.05
for(i in 1:200) {
  
  Zobs = rep(0, N)
  Zobs.0 = sample(c(rep(0, N0/2), rep(1, N1/2)), N/2, replace=FALSE)
  Zobs.1 = sample(c(rep(0, N0/2), rep(1, N1/2)), N/2, replace=FALSE)
  Zobs[strata] <- Zobs.1
  Zobs[!strata] <- Zobs.0
  data$Yobs = observe.Yobs(data, Zobs)
  Tobs = sum(Zobs*data$Yobs)/N1 - sum((1-Zobs)*data$Yobs)/N0
  
  T = c()
  for(j in 1:max_iter) {
    Z = rep(0, N)
    Z.0 = sample(c(rep(0, N0/2), rep(1, N1/2)), N/2, replace=FALSE)
    Z.1 = sample(c(rep(0, N0/2), rep(1, N1/2)), N/2, replace=FALSE)
    Z[strata] <- Z.1
    Z[!strata] <- Z.0
    T[j] = sum(Z*data$Yobs)/N1 - sum((1-Z)*data$Yobs)/N0
  }
  P[i] = mean(as.numeric(T >= Tobs))
}
omega.scrd[3] <- mean(as.numeric(P <= 0.05))
formatC(omega.scrd[3], format = "e", digits = 4)
```


```{r, include=TRUE, comment=NA, echo=TRUE}
data <- science.4
P = c()
alpha = 0.05
for(i in 1:200) {
  
  Zobs = rep(0, N)
  Zobs.0 = sample(c(rep(0, N0/2), rep(1, N1/2)), N/2, replace=FALSE)
  Zobs.1 = sample(c(rep(0, N0/2), rep(1, N1/2)), N/2, replace=FALSE)
  Zobs[strata] <- Zobs.1
  Zobs[!strata] <- Zobs.0
  data$Yobs = observe.Yobs(data, Zobs)
  Tobs = sum(Zobs*data$Yobs)/N1 - sum((1-Zobs)*data$Yobs)/N0
  
  T = c()
  for(j in 1:max_iter) {
    Z = rep(0, N)
    Z.0 = sample(c(rep(0, N0/2), rep(1, N1/2)), N/2, replace=FALSE)
    Z.1 = sample(c(rep(0, N0/2), rep(1, N1/2)), N/2, replace=FALSE)
    Z[strata] <- Z.1
    Z[!strata] <- Z.0
    T[j] = sum(Z*data$Yobs)/N1 - sum((1-Z)*data$Yobs)/N0
  }
  P[i] = mean(as.numeric(T >= Tobs))
}
omega.scrd[4] <- mean(as.numeric(P <= 0.05))
formatC(omega.scrd[4], format = "e", digits = 4)
```


The values of $w^{scrd}$ for each science are greater than for the complitly randomied design which means that the stratification helps improve the prower of the test.

```{r, include=TRUE, comment=NA, echo=TRUE}
data.frame("Science"=c(1, 2, 3, 4), "omega.scrd"=omega.scrd)
```


\newpage
## Questions 3



### Sub Question a

```{r, include=TRUE, comment=NA, echo=TRUE}
data <- science.1
Zobs = sample(c(rep(0, N0), rep(1, N1)), N, replace=FALSE)
data$Yobs = observe.Yobs(data, Zobs)

gamma <- 0.1
nb.assignments <- 0
rho <- c()
while(nb.assignments < 1000){
  rho_i = 2*gamma
  while(rho_i > gamma){
    Z = sample(Zobs, N, replace=FALSE)
    rho_i <- abs(sum(Z*X)/N1 - sum((1-Z)*X)/N0)
  }
  rho[nb.assignments] <- rho_i
  nb.assignments <- nb.assignments + 1
}
```




```{r, include=TRUE, comment=NA, echo=TRUE}
ggplot(data=data.frame("rho"=rho), aes(x=rho)) + 
  geom_histogram(bins=30) + 
  theme_bw()
```




### Sub Question b

```{r, include=TRUE, comment=NA, echo=TRUE}
gamma <- 0.1
```


```{r, include=TRUE, comment=NA, echo=TRUE}
data <- science.1
Zobs = sample(c(rep(0, N0), rep(1, N1)), N, replace=FALSE)

P = c()
alpha = 0.05
for(i in 1:200) {
  T = c()
  
  rho.temp = 2*gamma
  while(rho.temp > gamma){
    Zobs = sample(Zobs, N, replace=FALSE)
    rho.temp <- abs(sum(Z*X)/N1 - sum((1-Z)*X)/N0)
  }
  data$Yobs = observe.Yobs(data, Zobs)
  Tobs = sum(Zobs*data$Yobs)/N1 - sum((1-Zobs)*data$Yobs)/N0
  
  for(j in 1:max_iter) {
    
    rho.temp = 2*gamma
    while(rho.temp > gamma){
      Z = sample(Zobs, N, replace=FALSE)
      rho.temp <- abs(sum(Z*X)/N1 - sum((1-Z)*X)/N0)
    }
    T[j] = sum(Z*data$Yobs)/N1 - sum((1-Z)*data$Yobs)/N0
  }
  P[i] = mean(as.numeric(T >= Tobs))
}
omega.rerand[1] <- mean(as.numeric(P <= 0.05))
formatC(omega.rerand[1], format = "e", digits = 4)
```



\newpage
```{r, include=TRUE, comment=NA, echo=TRUE}
data <- science.2
Zobs = sample(c(rep(0, N0), rep(1, N1)), N, replace=FALSE)

P = c()
alpha = 0.05
for(i in 1:200) {
  T = c()
  
  rho.temp = 2*gamma
  while(rho.temp > gamma){
    Zobs = sample(Zobs, N, replace=FALSE)
    rho.temp <- abs(sum(Z*X)/N1 - sum((1-Z)*X)/N0)
  }
  data$Yobs = observe.Yobs(data, Zobs)
  Tobs = sum(Zobs*data$Yobs)/N1 - sum((1-Zobs)*data$Yobs)/N0
  
  for(j in 1:max_iter) {
    
    rho.temp = 2*gamma
    while(rho.temp > gamma){
      Z = sample(Zobs, N, replace=FALSE)
      rho.temp <- abs(sum(Z*X)/N1 - sum((1-Z)*X)/N0)
    }
    
    T[j] = sum(Z*data$Yobs)/N1 - sum((1-Z)*data$Yobs)/N0
  }
  P[i] = mean(as.numeric(T >= Tobs))
}
omega.rerand[2] <- mean(as.numeric(P <= 0.05))
formatC(omega.rerand[2], format = "e", digits = 4)
```



\newpage
```{r, include=TRUE, comment=NA, echo=TRUE}
data <- science.3
Zobs = sample(c(rep(0, N0), rep(1, N1)), N, replace=FALSE)

P = c()
alpha = 0.05
for(i in 1:200) {
  T = c()
  
  rho.temp = 2*gamma
  while(rho.temp > gamma){
    Zobs = sample(Zobs, N, replace=FALSE)
    rho.temp <- abs(sum(Z*X)/N1 - sum((1-Z)*X)/N0)
  }
  data$Yobs = observe.Yobs(data, Zobs)
  Tobs = sum(Zobs*data$Yobs)/N1 - sum((1-Zobs)*data$Yobs)/N0
  
  for(j in 1:max_iter) {
    
    rho.temp = 2*gamma
    while(rho.temp > gamma){
      Z = sample(Zobs, N, replace=FALSE)
      rho.temp <- abs(sum(Z*X)/N1 - sum((1-Z)*X)/N0)
    }
    
    T[j] = sum(Z*data$Yobs)/N1 - sum((1-Z)*data$Yobs)/N0
  }
  P[i] = mean(as.numeric(T >= Tobs))
}
omega.rerand[3] <- mean(as.numeric(P <= 0.05))
formatC(omega.rerand[3], format = "e", digits = 4)
```


\newpage
```{r, include=TRUE, comment=NA, echo=TRUE}
data <- science.4
Zobs = sample(c(rep(0, N0), rep(1, N1)), N, replace=FALSE)

P = c()
alpha = 0.05
for(i in 1:200) {
  T = c()
  
  rho.temp = 2*gamma
  while(rho.temp > gamma){
    Zobs = sample(Zobs, N, replace=FALSE)
    rho.temp <- abs(sum(Z*X)/N1 - sum((1-Z)*X)/N0)
  }
  data$Yobs = observe.Yobs(data, Zobs)
  Tobs = sum(Zobs*data$Yobs)/N1 - sum((1-Zobs)*data$Yobs)/N0
  
  for(j in 1:max_iter) {
    
    rho.temp = 2*gamma
    while(rho.temp > gamma){
      Z = sample(Zobs, N, replace=FALSE)
      rho.temp <- abs(sum(Z*X)/N1 - sum((1-Z)*X)/N0)
    }
    
    T[j] = sum(Z*data$Yobs)/N1 - sum((1-Z)*data$Yobs)/N0
  }
  P[i] = mean(as.numeric(T >= Tobs))
}
omega.rerand[4] <- mean(as.numeric(P <= 0.05))
formatC(omega.rerand[4], format = "e", digits = 4)
```


By upper bounded the the absolute value of the difference in means for covariates, we improved the power ofthe test for each ofthe sciences. Which makes sense since we are limitating the difference in means for covariates.

```{r, include=TRUE, comment=NA, echo=TRUE}
data.frame("Science"=c(1, 2, 3, 4), "omega.rerand"=omega.rerand)
```



\newpage
## Question 4


```{r, include=TRUE, comment=NA, echo=TRUE}
omega = data.frame("Design"=c(rep("crn", 4), rep("scrn", 4), rep("rerand", 4)),
                   "Science"=c(rep(c(1, 2, 3, 4), 3)),
                   "Omega"=c(omega.crd, omega.scrd, omega.rerand))
ggplot(data=omega, aes(x=Science, y=Omega)) +
  geom_line(aes(colour=Design))
```



